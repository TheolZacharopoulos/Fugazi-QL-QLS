%package cons.ql.parser
%class QLParser
%interface QLTokens
%semantic cons.ql.ast.ASTNode 

%token <Int> INT
%token <Boolean> BOOLEAN
%token <String> STRING
%token <Float> MONEY FLOAT
%token <Ident> IDENT
%token FORM IF ELSE
%token '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
%token '(' ')'

%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

%type <Expr> expr
%type <Block> statements
%type <Statement> statement

%{
import cons.ql.ast.*;
import cons.ql.ast.expr.*;
import cons.ql.ast.expr.unary.*;
import cons.ql.ast.expr.binary.*;
import cons.ql.ast.expr.statement.*;
%}

%%

 top : node { result = $1; } ;

 node : form | statement | expr;

 form : FORM IDENT block 
 	  ;

 block : '{' statements '}'
 	   ;

 statements : statements statement 
			| statement 			{ $$ = new Block($1); }
			;

 statement : question 
 		   | IF '(' relexpr ')' block elseBranch
 		   ;

 elseBranch : ELSE block
 			| /* empty */
 			;

 question : IDENT ':' questionType '{' STRING '}' 
 		  | IDENT ':' questionType '{' STRING assignment '}'
 		  ;

 questionType : BOOLEAN 
 			  | MONEY 
 			  | INT
 			  ;

 assignment : '(' expr ')';

 expr : arithexpr
 	  | relexpr
 	  | literal
 	  | '(' expr ')'	{ $$ = $2; }
 	  ;

 arithexpr : '+' expr %prec UPLUS { $$ = new Pos($2); }
	   	   | '-' expr %prec UMIN  { $$ = new Neg($2); }
	   	   | expr '*' expr		{ $$ = new Mul($1, $3); }
		   | expr '/' expr 		{ $$ = new Div($1, $3); }
		   | expr '+' expr		{ $$ = new Add($1, $3); }
		   | expr '-' expr		{ $$ = new Sub($1, $3); }
		   ;

 relexpr : '!' expr %prec UNOT  { $$ = new Not($2); }
 		 | expr EQ expr		    { $$ = new Eq($1, $3); }
		 | expr NEQ expr		{ $$ = new NEq($1, $3); }
		 | expr '>' expr		{ $$ = new GT($1, $3); }
		 | expr '<' expr		{ $$ = new LT($1, $3); }
		 | expr GEQ expr		{ $$ = new GEq($1, $3); }
		 | expr LEQ expr		{ $$ = new LEq($1, $3); }
		 | expr AND expr	    { $$ = new And($1, $3); }
	     | expr OR expr  		{ $$ = new Or($1, $3); }
	     ;

 literal : INT
		 | MONEY
		 | FLOAT
		 | BOOLEAN
		 | IDENT
		 ;
		 

%%
private QLLexer lexer; 

private ASTNode result;

public ASTNode getResult() {
  return result;
}

public QLParser(QLLexer lexer) { 
  this.lexer = lexer; 
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}