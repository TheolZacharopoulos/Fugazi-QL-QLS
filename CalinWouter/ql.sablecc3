// Used the skeleton of: http://improve.dk/writing-a-calculator-in-csharp-using-sablecc/
Package org.uva.student.calinwouter.ql.generated;

Helpers
    digit	= ['0' .. '9'];
    letter	= [['a' .. 'z'] + ['A' .. 'Z']];
    any	= [0 .. 0xFFFF];
    cr	= 13;
    lf	= 10;
    eol	= cr | lf | cr lf;
    no_enter= [any - [cr + lf]];

Tokens
    comment = '//' [any - [cr + lf]] eol?;
    tnot	= '!';
    number	= (digit+ | digit+ '.' digit+);
    or	= '||';
    and	= '&&';
    add	= '+';
    sub	= '-';
    mul	= '*';
    div	= '/';
    mod	= '%';
    lparen	= '(';
    rparen	= ')';
    tform	= 'form';
    lbrace	= '{';
    rbrace	= '}';
    colon	= ':';
    if	= 'if';
    else	= 'else';
    tbool	= 'boolean';
    ttrue	= 'true';
    tfalse	= 'false';
    tstring	= 'string';
    tint	= 'int';
    string	= '"' [no_enter - '"' ]* '"';
    teq	= '==';
    tneq	= '!=';
    tlt	= '<';
    tgt	= '>';
    tlte	= '<=';
    tgte	= '>=';
    blank	= (' ' | eol)+;
    ident	= (letter (digit | letter)*);

Ignored Tokens
    comment, blank;

Productions
    begin {-> begin}
        = {form} form                                   {-> New begin.form(form.form) }
        | {exp}  exp                                    {-> New begin.exp(exp.exp) }
        ;

    form {-> form}
        = tform ident lbrace [sl]:stmt_list rbrace	    {-> New form(ident, [sl.stmt])}
        ;

    stmt_list {-> stmt*}
        = stmt stmt_list_tail*                          {-> [stmt, stmt_list_tail.stmt]}
        ;

    stmt_list_tail {-> stmt}
        = stmt                                          {-> stmt}
        ;


    type {-> type}
        = {bool}	tbool					            {-> New type.bool()}
        | {string}	tstring					            {-> New type.string()}
        | {int}		tint					            {-> New type.int()}
        ;

    stmt {-> stmt}
        = {question}	ident colon string type			{-> New stmt.question(ident, string, type.type)}
        | {value}	ident colon string type lparen exp rparen	{-> New stmt.value(ident, string, type.type, exp.exp)}
        | {ifelse}	if lparen exp rparen lbrace
                    [then_stmt_list]:stmt_list
                rbrace else [lbrace2]:lbrace
                    [else_stmt_list]:stmt_list
                [rbrace2]:rbrace			            {-> New stmt.ifelse(exp, [then_stmt_list.stmt], [else_stmt_list.stmt])}
        | {if}		if lparen exp rparen lbrace
                    [then_stmt_list]:stmt_list
                rbrace			                		{-> New stmt.if(exp, [then_stmt_list.stmt])}
        ;

    exp {-> exp}
        = {logical}	logical			            		{-> logical.exp}
        ;

    logical {-> exp}
        = {or}		[left]:logical or [right]:cmp   	{-> New exp.or(left.exp, right.exp)}
        | {and}		[left]:logical and [right]:cmp	    {-> New exp.and(left.exp, right.exp)}
        | {cmp}	    cmp 					            {-> cmp.exp}
        ;

    cmp {-> exp}
        = {eq}		[left]:factor teq [right]:addend	{-> New exp.eq(left.exp, right.exp)}
        | {neq}		[left]:factor tneq [right]:addend   {-> New exp.neq(left.exp, right.exp)}
        | {lt}		[left]:factor tlt [right]:addend    {-> New exp.lt(left.exp, right.exp)}
        | {gt}		[left]:factor tgt [right]:addend	{-> New exp.gt(left.exp, right.exp)}
        | {lte}		[left]:factor tlte [right]:addend	{-> New exp.lte(left.exp, right.exp)}
        | {gte}		[left]:factor tgte [right]:addend	{-> New exp.gte(left.exp, right.exp)}
        | {addend}	addend					            {-> addend.exp}
        ;

    addend {-> exp}
        = {add}		[left]:addend add [right]:factor	{-> New exp.add(left.exp, right.exp)}
        | {sub}		[left]:addend sub [right]:factor	{-> New exp.sub(left.exp, right.exp)}
        | {factor}  factor                              {-> factor.exp}
        ;

    factor {-> exp}
        = {mul}		[left]:factor mul [right]:unary     {-> New exp.mul(left.exp, right.exp)}
        | {div}		[left]:factor div [right]:unary		{-> New exp.div(left.exp, right.exp)}
        | {mod}		[left]:factor mod [right]:unary		{-> New exp.mod(left.exp, right.exp)}
        | {unary}	unary			            		{-> unary.exp}
        ;

    unary {-> exp}
        = {not}		tnot unary			            	{-> New exp.not(unary.exp)}
        | {number}	number					            {-> New exp.number(number)}
        | {true}	ttrue					            {-> New exp.true()}
        | {false}	tfalse					            {-> New exp.false()}
        | {paren}	lparen exp rparen			        {-> exp.exp}
        | {ident}	ident					            {-> New exp.ident(ident)}
        ;

Abstract Syntax Tree
    begin
        = {form}        form
        | {exp}         exp
        ;
    form
        =			    [ident]:ident stmt*
        ;
    stmt
        = {question}	ident [str]:string [type]:type
        | {value}		ident [str]:string [type]:type [exp]:exp
        | {ifelse}		[exp]:exp [then_stmt_list]:stmt* [else_stmt_list]:stmt*
        | {if}			[exp]:exp [then_stmt_list]:stmt*
        ;
    type
        = {bool}
        | {string}
        | {int}
        ;
    exp
        = {add}			[left]:exp [right]:exp
        | {sub}			[left]:exp [right]:exp
        | {true}
        | {false}
        | {or}			[left]:exp [right]:exp
        | {and}			[left]:exp [right]:exp
        | {eq}			[left]:exp [right]:exp
        | {neq}			[left]:exp [right]:exp
        | {lt}			[left]:exp [right]:exp
        | {gt}			[left]:exp [right]:exp
        | {lte}			[left]:exp [right]:exp
        | {gte}			[left]:exp [right]:exp
        | {mul}			[left]:exp [right]:exp
        | {div}			[left]:exp [right]:exp
        | {mod}			[left]:exp [right]:exp
        | {not}			exp
        | {number}		number
        | {ident}		ident
        ;
